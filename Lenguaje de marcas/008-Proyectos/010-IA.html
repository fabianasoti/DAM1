<!doctype html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego Estilo Pac-Platformer</title>
<style>
  body {
    background-color: #1a1a1a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    color: white;
    font-family: 'Courier New', Courier, monospace;
  }
  canvas {
    border: 3px solid #555;
    /* Un fondo estilo cielo nocturno arcade */
    background: linear-gradient(to bottom, #000033, #2a2a72);
    box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
  }
</style>
</head>

<body>
<canvas></canvas>

<script>

// =====================
// CLASES
// =====================

class Jugador {
  constructor() {
    this.iniciarPosicion();
    this.w = 28;
    this.h = 28;
    this.vx = 0;
    this.vy = 0;
    // Físicas ajustadas para mejor control
    this.speedForce = 1.5;
    this.friction = 0.85;
    this.jumpStrength = -14;
    this.vidas = 3;
    this.enSuelo = false;
    this.color = "#FFD700"; // Color Pac-man dorado
    this.mirandoDerecha = true;
  }

  iniciarPosicion() {
    this.x = 50;
    this.y = 400;
    this.vx = 0;
    this.vy = 0;
  }

  actualizar() {
    // Aplicar fricción para movimiento más suave
    this.vx *= this.friction;
    this.x += this.vx;

    // Gravedad
    this.vy += gravedad;
    this.y += this.vy;

    this.enSuelo = false;

    // Colisiones con plataformas
    plataformas.forEach(p => {
      // Colisión simple desde arriba
      if (this.x + this.w > p.x + 5 && this.x < p.x + p.w - 5) { // Margen lateral pequeño
          if (this.y + this.h >= p.y && this.y + this.h <= p.y + p.h && this.vy >= 0) {
              this.y = p.y - this.h;
              this.vy = 0;
              this.enSuelo = true;
          }
      }
    });

    // Límites del canvas
    if (this.x < 0) { this.x = 0; this.vx = 0; }
    if (this.x + this.w > canvas.width) { this.x = canvas.width - this.w; this.vx = 0; }
    // Si cae al vacío (aunque hay suelo, por seguridad)
    if (this.y > canvas.height) this.iniciarPosicion();

    this.dibujar();
  }

  dibujar() {
    ctx.save();
    // Dibujar cuerpo redondo
    ctx.fillStyle = this.color;
    ctx.beginPath();
    let centerX = this.x + this.w / 2;
    let centerY = this.y + this.h / 2;
    ctx.arc(centerX, centerY, this.w / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "orange";
    ctx.stroke();

    // Dibujar ojo para indicar dirección
    ctx.fillStyle = "black";
    let eyeX = this.mirandoDerecha ? centerX + 6 : centerX - 6;
    ctx.beginPath();
    ctx.arc(eyeX, centerY - 3, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// NPC ahora es un "Fantasma" patrullero
class Fantasma {
  constructor(x, y, color, velocidad) {
    this.x = x;
    this.y = y;
    this.w = 30;
    this.h = 30;
    this.vx = velocidad;
    this.color = color;
    // Los fantasmas flotan, no les afecta la gravedad de las plataformas
  }

  actualizar() {
    this.x += this.vx;

    // Rebotar en los bordes de la pantalla
    if (this.x < 0 || this.x + this.w > canvas.width) {
        this.vx *= -1;
    }
    this.dibujar();
  }

  dibujar() {
    ctx.save();
    ctx.fillStyle = this.color;
    
    // Cabeza redonda
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2 - 5, this.w/2, Math.PI, 0);
    // Cuerpo hacia abajo
    ctx.lineTo(this.x + this.w, this.y + this.h);
    // Parte inferior ondulada (simplificada)
    ctx.lineTo(this.x + this.w*0.75, this.y + this.h - 5);
    ctx.lineTo(this.x + this.w*0.5, this.y + this.h);
    ctx.lineTo(this.x + this.w*0.25, this.y + this.h - 5);
    ctx.lineTo(this.x, this.y + this.h);
    ctx.fill();

    // Ojos
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(this.x + 8, this.y + 10, 4, 0, Math.PI*2);
    ctx.arc(this.x + 22, this.y + 10, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "blue";
    ctx.beginPath();
    // Pupilas mirando hacia donde se mueven
    let pupilaOffset = this.vx > 0 ? 2 : -2;
    ctx.arc(this.x + 8 + pupilaOffset, this.y + 10, 2, 0, Math.PI*2);
    ctx.arc(this.x + 22 + pupilaOffset, this.y + 10, 2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }
}

// Clase para las recompensas (monedas/pac-dots)
class Moneda {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 16;
        this.h = 16;
        this.recogida = false;
        this.timer = 0;
    }
    actualizar() {
        if(this.recogida) return;
        this.timer += 0.1;
        this.dibujar();
    }
    dibujar() {
        ctx.save();
        ctx.fillStyle = "#FFDD44";
        ctx.strokeStyle = "#FFAA00";
        ctx.lineWidth = 2;
        
        // Pequeño efecto de flotación/giro
        let offsetY = Math.sin(this.timer) * 3;
        
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y + this.h/2 + offsetY, this.w/2, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // Brillo interior
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(this.x + this.w/2 - 3, this.y + this.h/2 + offsetY - 3, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

class Plataforma {
  constructor(x, y, w, h) {
    this.x = x; this.y = y; this.w = w; this.h = h;
  }
  dibujar() {
      ctx.save();
      // Estilo ladrillo arcade
      let grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
      grad.addColorStop(0, "#7d3e23");
      grad.addColorStop(1, "#4a2515");
      ctx.fillStyle = grad;
      ctx.fillRect(this.x, this.y, this.w, this.h);
      
      // Borde superior
      ctx.fillStyle = "#a05b3c";
      ctx.fillRect(this.x, this.y, this.w, 4);

      // Patrón de ladrillos simple
      ctx.strokeStyle = "#331100";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=0; i < this.w; i+=20) {
          ctx.moveTo(this.x + i, this.y);
          ctx.lineTo(this.x + i, this.y + this.h);
      }
       for(let j=0; j < this.h; j+=15) {
          ctx.moveTo(this.x, this.y + j);
          ctx.lineTo(this.x + this.w, this.y + j);
      }
      ctx.stroke();
      
      // Borde exterior
      ctx.strokeStyle = "#220000";
      ctx.lineWidth = 2;
      ctx.strokeRect(this.x, this.y, this.w, this.h);
      ctx.restore();
  }
}

// =====================
// CONFIGURACIÓN
// =====================

var canvas = document.querySelector("canvas");
var ctx = canvas.getContext("2d");
canvas.width = 600; // Un poco más ancho
canvas.height = 500;

var gravedad = 0.6; // Gravedad un poco más suave
var fps = 1000 / 60;
var temporizador;
var puntuacion = 0;
var invulnerable = 0; // Tiempo de invulnerabilidad tras ser golpeado

var jugador = new Jugador();

// Definimos un mapa más complejo tipo laberinto
var plataformas = [
  new Plataforma(0, 470, 600, 30),  // Suelo principal
  new Plataforma(0, 350, 150, 20),
  new Plataforma(450, 350, 150, 20),
  new Plataforma(200, 280, 200, 20), // Centro medio
  new Plataforma(50, 200, 120, 20),
  new Plataforma(430, 200, 120, 20),
  new Plataforma(250, 130, 100, 20), // Centro alto
];

// Creamos varios fantasmas de colores
var fantasmas = [
    new Fantasma(50, 315, "red", 2),
    new Fantasma(500, 165, "pink", -2.5),
    new Fantasma(20, 435, "cyan", 1.5),
    new Fantasma(400, 95, "orange", -3)
];

var monedas = [];
// Función auxiliar para poner monedas sobre plataformas
function colocarMonedas() {
    plataformas.forEach(p => {
        // No poner monedas en el suelo principal para forzar el salto
        if(p.y < 450) {
            let numMonedas = Math.floor(p.w / 30);
            let espacio = p.w / (numMonedas + 1);
            for(let i=1; i <= numMonedas; i++) {
                monedas.push(new Moneda(p.x + espacio * i - 8, p.y - 25));
            }
        }
    });
}
colocarMonedas();


// =====================
// BUCLE PRINCIPAL
// =====================

inicio();

function inicio() {
  temporizador = setTimeout(bucle, fps);
}

function bucle() {
  // Limpiar y dibujar fondo
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Dibujar Plataformas
  plataformas.forEach(p => p.dibujar());

  // Dibujar y actualizar Monedas
  let monedasRestantes = 0;
  monedas.forEach(m => {
      m.actualizar();
      if(!m.recogida) {
          monedasRestantes++;
          // Colisión Jugador - Moneda
          if(colisionCores(jugador, m)) {
              m.recogida = true;
              puntuacion += 100;
          }
      }
  });

  // Actualizar Jugador
  jugador.actualizar();

  // Manejar Invulnerabilidad (parpadeo)
  if(invulnerable > 0) {
      invulnerable--;
      // Si es invulnerable, hacerlo semitransparente a ratos
      if(invulnerable % 10 < 5) ctx.globalAlpha = 0.5;
  } else {
      ctx.globalAlpha = 1.0;
  }

  // Actualizar y dibujar Fantasmas
  fantasmas.forEach(f => {
    f.actualizar();
    
    // Colisión Jugador - Fantasma
    if (invulnerable <= 0 && colisionCores(jugador, f)) {
        jugador.vidas--;
        invulnerable = 60; // 1 segundo de invulnerabilidad (60 frames)
        jugador.vy = -8; // Pequeño empujón hacia arriba al ser golpeado
        
        if (jugador.vidas <= 0) {
            gameOver("¡Te atraparon! Puntuación final: " + puntuacion);
            return; // Detener el bucle
        }
    }
  });

  ctx.globalAlpha = 1.0; // Restaurar alpha por si acaso

  // HUD (Interfaz)
  dibujarHUD();

  // Condición de Victoria
  if (monedasRestantes === 0) {
      gameOver("¡NIVEL COMPLETADO! Puntuación: " + puntuacion);
      return;
  }

  temporizador = setTimeout(bucle, fps);
}

function dibujarHUD() {
    ctx.fillStyle = "white";
    ctx.font = "bold 20px Courier New";
    ctx.textAlign = "left";
    ctx.fillText("PUNTOS: " + puntuacion, 20, 30);
    
    // Dibujar vidas como pequeños iconos
    ctx.fillText("VIDAS:", 450, 30);
    for(let i=0; i<jugador.vidas; i++) {
        ctx.save();
        ctx.translate(530 + i*25, 24);
        ctx.fillStyle = jugador.color;
        ctx.beginPath();
        ctx.arc(0,0, 10, 0.2 * Math.PI, 1.8 * Math.PI);
        ctx.lineTo(0,0);
        ctx.fill();
        ctx.restore();
    }
}

function gameOver(mensaje) {
    clearTimeout(temporizador);
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0,0, canvas.width, canvas.height);
    
    ctx.fillStyle = "white";
    ctx.font = "bold 24px Courier New";
    ctx.textAlign = "center";
    ctx.fillText(mensaje, canvas.width/2, canvas.height/2);
    ctx.font = "20px Courier New";
    ctx.fillText("Pulsa F5 para reiniciar", canvas.width/2, canvas.height/2 + 40);
}

// =====================
// CONTROLES
// =====================

// Usamos un objeto para rastrear teclas mantenidas para movimiento más fluido
var teclas = {};

document.onkeydown = e => {
    teclas[e.key] = true;
    
    // Salto (solo al presionar, no mantener)
    if ((e.key === "w" || e.key === "ArrowUp" || e.key === " ") && jugador.enSuelo) {
        jugador.vy = jugador.jumpStrength;
        jugador.enSuelo = false;
    }
};

document.onkeyup = e => {
    teclas[e.key] = false;
};

// Función para aplicar input en cada frame
function aplicarInput() {
    if (teclas["a"] || teclas["ArrowLeft"]) {
        jugador.vx -= jugador.speedForce;
        jugador.mirandoDerecha = false;
    }
    if (teclas["d"] || teclas["ArrowRight"]) {
        jugador.vx += jugador.speedForce;
        jugador.mirandoDerecha = true;
    }
}

// Modificamos el update del jugador para usar el nuevo input
var updateOriginalJugador = jugador.actualizar.bind(jugador);
jugador.actualizar = function() {
    aplicarInput();
    updateOriginalJugador();
};


// =====================
// COLISIONES (Centro a Centro para mejor precisión visual)
// =====================

function colisionCores(a, b) {
    // Calculamos los centros
    let aCenterX = a.x + a.w/2;
    let aCenterY = a.y + a.h/2;
    let bCenterX = b.x + b.w/2;
    let bCenterY = b.y + b.h/2;
    
    // Usamos radios aproximados (promedio de ancho/alto)
    let aRadius = (a.w + a.h) / 4;
    let bRadius = (b.w + b.h) / 4;
    
    // Distancia entre centros
    let dx = aCenterX - bCenterX;
    let dy = aCenterY - bCenterY;
    let distancia = Math.sqrt(dx*dx + dy*dy);
    
    // Si la distancia es menor que la suma de radios, hay colisión
    return distancia < (aRadius + bRadius);
}

// Mantenemos la colisión rectangular solo para las plataformas
function colisionRect(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

</script>
</body>
</html>
