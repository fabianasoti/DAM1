<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Pastel Paint Studio</title>
<style>
  /* --- PASTEL THEME & UI --- */
  :root {
    --bg-color: #fdfbf7;      /* Warm white */
    --panel-bg: #ffffff;      /* Pure white */
    --text-color: #5d5d5d;    /* Soft gray */
    --accent-blue: #a2d2ff;   /* Pastel Blue */
    --accent-pink: #ffc8dd;   /* Pastel Pink */
    --accent-purple: #cdb4db; /* Pastel Purple */
    --border-color: #eee;
    --shadow: 0 4px 15px rgba(0,0,0,0.05);
  }

  body {
    margin: 0;
    font-family: 'Segoe UI', 'Roboto', sans-serif; /* Friendly font */
    height: 100vh;
    display: flex;
    background: var(--bg-color);
    color: var(--text-color);
    overflow: hidden;
    user-select: none;
  }

  /* TOOLBAR */
  #toolbar {
    width: 260px;
    background: var(--panel-bg);
    padding: 15px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 12px;
    border-right: 1px solid var(--border-color);
    box-shadow: var(--shadow);
    z-index: 10;
  }

  h3 {
    margin: 8px 0 4px;
    font-size: 12px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: 600;
  }

  /* INPUTS & BUTTONS */
  button, select, input[type="range"], .color-wrapper {
    background: #f8f9fa;
    color: var(--text-color);
    border: 1px solid #e0e0e0;
    border-radius: 12px; /* Super round */
    cursor: pointer;
    box-sizing: border-box;
    transition: all 0.2s ease;
    outline: none;
  }

  button:hover, select:hover {
    background: #f0f0f0;
    transform: translateY(-1px);
  }

  button:active {
    transform: translateY(1px);
  }

  /* Active State (Pastel Blue) */
  button.active {
    background: var(--accent-blue);
    color: #fff;
    border-color: var(--accent-blue);
    box-shadow: 0 4px 10px rgba(162, 210, 255, 0.4);
  }

  /* TOOLS GRID */
  #toolsGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
  }

  .toolBtn {
    height: 48px;
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }

  /* BRUSH SELECTOR */
  #brushType {
    width: 100%;
    padding: 8px;
    font-size: 14px;
    margin-bottom: 5px;
  }

  /* COLOR PICKER STYLING */
  .color-wrapper {
    display: flex;
    align-items: center;
    padding: 4px;
    gap: 8px;
    background: #fff;
  }
  
  input[type="color"] {
    -webkit-appearance: none;
    border: none;
    width: 32px;
    height: 32px;
    border-radius: 8px;
    cursor: pointer;
    background: none;
    padding: 0;
  }
  input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
  input[type="color"]::-webkit-color-swatch { border: none; border-radius: 8px; }

  /* MAIN AREA */
  #main {
    flex: 1;
    position: relative;
    background: #e5e5e5; /* Neutral gray for canvas backdrop */
    background-image: radial-gradient(#ccc 1px, transparent 1px);
    background-size: 20px 20px;
    overflow: hidden;
    cursor: crosshair;
  }

  #viewport {
    position: relative;
    transform-origin: 0 0;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    background: white; /* Default canvas color */
  }

  .layerCanvas {
    position: absolute;
    left: 0;
    top: 0;
  }

  /* LAYERS LIST */
  #layersList {
    flex: 1;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 6px;
    background: #fdfdfd;
  }

  #layersList button {
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 4px;
    text-align: left;
    font-size: 13px;
    background: white;
    border: 1px solid transparent;
  }
  
  #layersList button.activeLayer {
    background: var(--accent-pink); /* Active layer is Pink */
    color: #4a2c36;
    font-weight: 600;
  }

  /* UTILITY CLASSES */
  .wideBtn { width: 100%; padding: 10px; font-weight: 500; }
  .row { display: flex; gap: 8px; align-items: center; }
  #sizeLabel { font-size: 12px; width: 35px; text-align: right; }
  
  /* Range Slider Styling */
  input[type=range] {
    height: 6px;
    background: #ddd;
    border-radius: 5px;
    border: none;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: var(--accent-purple);
    cursor: pointer;
    margin-top: -5px;
  }
</style>
</head>
<body>

<div id="toolbar">
  <h3>Tools</h3>
  <div id="toolsGrid">
    <button id="toolBrush" class="toolBtn active" title="Brush">üñåÔ∏è</button>
    <button id="toolEraser" class="toolBtn" title="Eraser">üßΩ</button>
    <button id="toolLine" class="toolBtn" title="Line">üìè</button>
    <button id="toolRect" class="toolBtn" title="Rectangle">‚óªÔ∏è</button>
    <button id="toolBucket" class="toolBtn" title="Paint Bucket">ü™£</button>
  </div>

  <h3>Brush Style</h3>
  <select id="brushType">
    <option value="round">üñäÔ∏è Smooth Pen</option>
    <option value="marker">üñçÔ∏è Marker (See-thru)</option>
    <option value="spray">üí® Spray Paint</option>
    <option value="pixel">üëæ Pixel Square</option>
  </select>

  <h3>Color</h3>
  <div class="color-wrapper">
    <input type="color" id="colorPicker" value="#ff9a9e">
    <span style="font-size:12px; color:#999;">Pick Color</span>
  </div>

  <h3>Size</h3>
  <div class="row">
    <input type="range" id="sizePicker" min="1" max="80" value="10" style="flex:1">
    <span id="sizeLabel">10px</span>
  </div>

  <h3>History</h3>
  <div class="row">
    <button id="undoBtn" class="wideBtn">‚Ü©Ô∏è Undo</button>
    <button id="redoBtn" class="wideBtn">‚Ü™Ô∏è Redo</button>
  </div>

  <h3>Layers</h3>
  <div id="layersList"></div>
  <div class="row">
      <button id="addLayerBtn" class="wideBtn">‚ûï New</button>
      <button id="deleteLayerBtn" class="wideBtn">üóëÔ∏è Del</button>
  </div>

  <div style="margin-top:auto"></div> <h3>File</h3>
  <button id="saveBtn" class="wideBtn" style="background:var(--accent-blue); color:white; border:none;">üíæ Save Image</button>
</div>

<div id="main">
  <div id="centerWrap" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);">
    <div id="viewport"></div>
  </div>
</div>

<script>
  // --- CONFIGURATION ---
  const WIDTH = 800;
  const HEIGHT = 600;
  
  // --- DOM ELEMENTS ---
  const viewport = document.getElementById("viewport");
  const main = document.getElementById("main");
  const toolButtons = {
    brush: document.getElementById("toolBrush"),
    eraser: document.getElementById("toolEraser"),
    line: document.getElementById("toolLine"),
    rect: document.getElementById("toolRect"),
    bucket: document.getElementById("toolBucket"),
  };
  const brushTypeSelect = document.getElementById("brushType");
  const colorPicker = document.getElementById("colorPicker");
  const sizePicker = document.getElementById("sizePicker");
  const sizeLabel = document.getElementById("sizeLabel");
  const layersList = document.getElementById("layersList");
  
  // --- STATE ---
  let layers = [];
  let activeLayerIndex = 0;
  
  let tool = "brush";
  let brushStyle = "round";
  let isDrawing = false;
  let startX = 0, startY = 0;
  let lastX = 0, lastY = 0;
  let snapshot = null;
  
  let scale = 1;
  let offsetX = 0, offsetY = 0;
  let isPanning = false;
  let panStart = {x:0, y:0};

  // --- INIT VIEWPORT ---
  viewport.style.width = WIDTH + "px";
  viewport.style.height = HEIGHT + "px";

  // --- BACKGROUND ---
  const bgCanvas = document.createElement("canvas");
  bgCanvas.width = WIDTH;
  bgCanvas.height = HEIGHT;
  const bgCtx = bgCanvas.getContext("2d");
  bgCtx.fillStyle = "#ffffff"; // Default white paper
  bgCtx.fillRect(0,0,WIDTH,HEIGHT);
  viewport.appendChild(bgCanvas);

  // --- TOOLS SYSTEM ---
  function setTool(t) {
    tool = t;
    // Update UI
    for (let k in toolButtons) toolButtons[k].classList.remove("active");
    toolButtons[t].classList.add("active");
    
    // Disable brush select if not using brush
    brushTypeSelect.disabled = (tool !== 'brush' && tool !== 'eraser');
  }

  Object.keys(toolButtons).forEach(k => {
    toolButtons[k].onclick = () => setTool(k);
  });

  brushTypeSelect.onchange = () => {
    brushStyle = brushTypeSelect.value;
  };

  sizePicker.oninput = () => {
    sizeLabel.textContent = sizePicker.value + "px";
  };

  // --- COLOR UTILS (HEX to RGB) ---
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : {r:0, g:0, b:0};
  }

  // --- LAYER SYSTEM ---
  function createLayer(name) {
    const canvas = document.createElement("canvas");
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.className = "layerCanvas";
    viewport.appendChild(canvas);

    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    
    layers.push({
      name, canvas, ctx,
      history: [], redo: []
    });
    
    activeLayerIndex = layers.length - 1;
    pushHistory();
    refreshLayersUI();
  }

  function refreshLayersUI() {
    layersList.innerHTML = "";
    [...layers].reverse().forEach((layer) => {
      const realIndex = layers.indexOf(layer);
      const btn = document.createElement("button");
      btn.textContent = (realIndex === activeLayerIndex ? "üëÅÔ∏è " : "") + layer.name;
      if (realIndex === activeLayerIndex) btn.classList.add("activeLayer");
      btn.onclick = () => {
        activeLayerIndex = realIndex;
        refreshLayersUI();
      };
      layersList.appendChild(btn);
    });
  }

  document.getElementById("addLayerBtn").onclick = () => createLayer("Layer " + (layers.length + 1));
  document.getElementById("deleteLayerBtn").onclick = () => {
    if (layers.length <= 1) return alert("Keep at least one layer!");
    viewport.removeChild(layers[activeLayerIndex].canvas);
    layers.splice(activeLayerIndex, 1);
    activeLayerIndex = Math.max(0, activeLayerIndex - 1);
    refreshLayersUI();
  };

  function activeLayer() { return layers[activeLayerIndex]; }

  // --- HISTORY (UNDO/REDO) ---
  function pushHistory() {
    const layer = activeLayer();
    layer.history.push(layer.canvas.toDataURL());
    if (layer.history.length > 20) layer.history.shift();
    layer.redo = [];
  }

  document.getElementById("undoBtn").onclick = () => {
    const layer = activeLayer();
    if (layer.history.length > 1) {
      layer.redo.push(layer.history.pop());
      const img = new Image();
      img.onload = () => {
        layer.ctx.clearRect(0,0,WIDTH,HEIGHT);
        layer.ctx.drawImage(img,0,0);
      };
      img.src = layer.history[layer.history.length-1];
    }
  };

  document.getElementById("redoBtn").onclick = () => {
    const layer = activeLayer();
    if (layer.redo.length > 0) {
      const data = layer.redo.pop();
      layer.history.push(data);
      const img = new Image();
      img.onload = () => {
        layer.ctx.clearRect(0,0,WIDTH,HEIGHT);
        layer.ctx.drawImage(img,0,0);
      };
      img.src = data;
    }
  };

  // --- FLOOD FILL ALGORITHM (THE BUCKET) ---
  function floodFill(ctx, startX, startY, fillColor) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    // Get image data
    const imgData = ctx.getImageData(0, 0, w, h);
    const data = imgData.data;
    
    // Get target color (the color we clicked on)
    const pixelPos = (startY * w + startX) * 4;
    const startR = data[pixelPos];
    const startG = data[pixelPos + 1];
    const startB = data[pixelPos + 2];
    const startA = data[pixelPos + 3];

    // Convert hex fill color to RGB
    const fillRgb = hexToRgb(fillColor);
    const fillR = fillRgb.r;
    const fillG = fillRgb.g;
    const fillB = fillRgb.b;
    const fillA = 255;

    // Don't fill if color is same
    if (startR === fillR && startG === fillG && startB === fillB && startA === fillA) return;

    const stack = [[startX, startY]];

    while (stack.length) {
      const [x, y] = stack.pop();
      const pos = (y * w + x) * 4;

      // Check boundaries and color match
      if (x < 0 || x >= w || y < 0 || y >= h) continue;
      
      const r = data[pos], g = data[pos+1], b = data[pos+2], a = data[pos+3];
      
      // If current pixel matches starting pixel
      if (r === startR && g === startG && b === startB && a === startA) {
        // Color it
        data[pos] = fillR;
        data[pos+1] = fillG;
        data[pos+2] = fillB;
        data[pos+3] = fillA;

        // Add neighbors
        stack.push([x + 1, y]);
        stack.push([x - 1, y]);
        stack.push([x, y + 1]);
        stack.push([x, y - 1]);
      }
    }
    
    ctx.putImageData(imgData, 0, 0);
  }

  // --- DRAWING LOGIC ---
  function getMousePos(e) {
    const rect = viewport.getBoundingClientRect();
    return {
      x: Math.floor((e.clientX - rect.left) / scale),
      y: Math.floor((e.clientY - rect.top) / scale)
    };
  }

  // Helper for Spray Paint
  function spray(ctx, x, y, size, color) {
    const density = size * 2;
    ctx.fillStyle = color;
    for (let i = 0; i < density; i++) {
      const offsetX = (Math.random() - 0.5) * size * 2;
      const offsetY = (Math.random() - 0.5) * size * 2;
      // Draw tiny dots within radius
      if (offsetX*offsetX + offsetY*offsetY <= size*size) {
        ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
      }
    }
  }

  main.addEventListener("mousedown", (e) => {
    if (e.button === 1 || e.shiftKey) { // Pan
      isPanning = true;
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      return;
    }
    
    if (e.button !== 0) return; // Only Left Click

    const pos = getMousePos(e);
    startX = pos.x; 
    startY = pos.y;
    lastX = pos.x; 
    lastY = pos.y;
    
    const layer = activeLayer();
    const ctx = layer.ctx;
    const color = colorPicker.value;
    const size = parseInt(sizePicker.value, 10);

    // BUCKET TOOL
    if (tool === "bucket") {
      floodFill(ctx, startX, startY, color);
      pushHistory();
      return;
    }

    isDrawing = true;

    // Setup Context
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = size;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    
    if (tool === "line" || tool === "rect") {
      snapshot = ctx.getImageData(0, 0, WIDTH, HEIGHT);
    } 
    else if (tool === "brush") {
      if (brushStyle === "round") {
        ctx.globalAlpha = 1.0;
        ctx.beginPath();
        ctx.lineTo(startX, startY); // Dot
        ctx.stroke();
      } else if (brushStyle === "marker") {
        ctx.globalAlpha = 0.5; // See-through
        ctx.globalCompositeOperation = "source-over"; // Layering effect
        ctx.beginPath();
        ctx.lineTo(startX, startY);
        ctx.stroke();
      } else if (brushStyle === "pixel") {
         ctx.globalAlpha = 1.0;
         ctx.lineCap = "butt"; // Flat edges
         ctx.fillRect(startX - size/2, startY - size/2, size, size);
      } else if (brushStyle === "spray") {
         ctx.globalAlpha = 1.0;
         spray(ctx, startX, startY, size, color);
      }
    } 
    else if (tool === "eraser") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.globalAlpha = 1.0;
      ctx.beginPath();
      ctx.arc(startX, startY, size/2, 0, Math.PI*2);
      ctx.fill();
    }
  });

  main.addEventListener("mousemove", (e) => {
    if (isPanning) {
      offsetX += e.clientX - panStart.x;
      offsetY += e.clientY - panStart.y;
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      viewport.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
      return;
    }

    if (!isDrawing) return;
    
    const pos = getMousePos(e);
    const layer = activeLayer();
    const ctx = layer.ctx;
    const size = parseInt(sizePicker.value, 10);
    const color = colorPicker.value;

    if (tool === "brush") {
      if (brushStyle === "spray") {
        spray(ctx, pos.x, pos.y, size, color);
      } else if (brushStyle === "pixel") {
        ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size);
      } else {
        // Round & Marker use standard stroke
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
      }
      lastX = pos.x; lastY = pos.y;
    }
    else if (tool === "eraser") {
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      lastX = pos.x; lastY = pos.y;
    }
    else if (tool === "line") {
      ctx.putImageData(snapshot, 0, 0);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }
    else if (tool === "rect") {
      ctx.putImageData(snapshot, 0, 0);
      ctx.fillRect(startX, startY, pos.x - startX, pos.y - startY);
    }
  });

  window.addEventListener("mouseup", () => {
    if (isDrawing) {
      activeLayer().ctx.globalAlpha = 1.0; // Reset alpha
      activeLayer().ctx.globalCompositeOperation = "source-over"; // Reset blend
      pushHistory();
    }
    isDrawing = false;
    isPanning = false;
  });

  // --- SAVE ---
  document.getElementById("saveBtn").onclick = () => {
    const exportCanvas = document.createElement("canvas");
    exportCanvas.width = WIDTH;
    exportCanvas.height = HEIGHT;
    const ectx = exportCanvas.getContext("2d");
    
    // Draw white background first
    ectx.fillStyle = "#ffffff";
    ectx.fillRect(0,0,WIDTH,HEIGHT);
    
    // Draw all layers
    layers.forEach(l => ectx.drawImage(l.canvas, 0, 0));
    
    const link = document.createElement("a");
    link.download = "pastel_art.png";
    link.href = exportCanvas.toDataURL();
    link.click();
  };

  // --- INITIALIZE ---
  createLayer("Background");
  // Center view
  const rect = main.getBoundingClientRect();
  offsetX = (rect.width - WIDTH)/2;
  offsetY = (rect.height - HEIGHT)/2;
  viewport.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1)`;

</script>
</body>
</html>
